'use strict';

var typeOf = require('./typeOf');
var getConfig = require('./config');
var getPrefix = require('./getPrefix');

/**
 * value types that not require indent after property name that include the value
 */
var NO_INDENT_TYPES = ['object', 'array'];

module.exports = function yamlifyObject(target, config) {
  var _getConfig = getConfig(config),
      colors = _getConfig.colors,
      prefix = _getConfig.prefix,
      postfix = _getConfig.postfix,
      dateToString = _getConfig.dateToString,
      errorToString = _getConfig.errorToString,
      indentChars = _getConfig.indent;

  var seen = new Map();

  /**
   * Object to yaml string formatter
   *
   * @param {Object} obj
   * @param {number} [indentLength=1]
   * @returns {string}
   */
  function objectProperty(obj) {
    var indentLength = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    var inArray = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

    if (Object.keys(obj).length === 0) {
      return ' {}';
    }

    var str = '\n';
    var objectPrefix = getPrefix(indentLength, indentChars);

    Object.keys(obj).forEach(function (name) {
      var value = obj[name];
      var type = typeOf(value);
      var inArrayPrefix = getPrefix(inArray, '  ');
      var afterPropsIndent = NO_INDENT_TYPES.indexOf(type) !== -1 ? '' : ' ';
      var valueString = checkCircular(value) ? ' [Circular]' : typifiedString(type, value, indentLength + 1, inArray);

      str += `${inArrayPrefix}${objectPrefix}${name}:${afterPropsIndent}${valueString}\n`;
    });

    return str.substring(0, str.length - 1);
  }

  /**
   * Array to yaml string formatter
   *
   * @param {Array} values
   * @param {number} [indentLength=1]
   * @return {string}
   */
  function arrayProperty(values) {
    var indentLength = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    var inArray = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

    if (values.length === 0) {
      return ' []';
    }

    var str = '\n';
    var arrayPrefix = getPrefix(indentLength, indentChars);

    values.forEach(function (value) {
      var type = typeOf(value);
      var inArrayPrefix = getPrefix(inArray, '  ');
      var valueString = checkCircular(value) ? '[Circular]' : typifiedString(type, value, indentLength, inArray + 1).toString().trimLeft();

      str += `${inArrayPrefix}${arrayPrefix}- ${valueString}\n`;
    });

    return str.substring(0, str.length - 1);
  }

  function typifiedString(type, value, indentLength, inArray) {
    switch (type) {
      case 'array':
        return arrayProperty(value, indentLength, inArray);
      case 'object':
        return objectProperty(value, indentLength, inArray);
      case 'string':
        return colors.string(value);
      case 'symbol':
        return colors.symbol(value.toString());
      case 'number':
        return colors.number(value);
      case 'boolean':
        return colors.boolean(value);
      case 'null':
        return colors.null('null');
      case 'undefined':
        return colors.undefined('undefined');
      case 'date':
        return colors.date(dateToString(value));
      case 'error':
        return colors.error(errorToString(value));
      default:
        if (value && value.toString) {
          return value.toString();
        }
        return Object.prototype.toString.call(value);
    }
  }

  function checkCircular(value) {
    if (!(['object', 'array'].indexOf(typeOf(value)) !== -1)) {
      return false;
    }

    if (seen.has(value)) {
      return true;
    }

    seen.set(value);

    return false;
  }

  var string = '';

  seen.set(target);

  if (typeOf(target) === 'object' && Object.keys(target).length > 0) {
    string = objectProperty(target);
  } else if (typeOf(target) === 'array' && target.length > 0) {
    string = arrayProperty(target);
  }

  if (string.length === 0) {
    return '';
  }

  return `${prefix}${string.slice(1)}${postfix}`;
};